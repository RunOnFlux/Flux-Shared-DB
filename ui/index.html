<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flux Shared DB Dashboard</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/air-datepicker/2.2.3/css/datepicker.min.css" />

    <style>
      .navbar { border-bottom: #ffffff41 1px solid; }
      .navbar i { margin-right: 10px; }
      html, body { height: 100%; margin: 0; padding: 0; }
      #app { min-height: 100vh; display: flex; flex-direction: column; background: linear-gradient(-45deg, #e73c7e, #23a6d5); background-size: 100% 100%; }
      main { flex-grow: 1; }
      .card-header { background-color: #fff; color: #898989; }
      .card-header h3 { font-weight: 100; }
      footer { flex-shrink: 0; margin-top: auto; }
      .clickable { cursor: pointer; }
      .spinner-border-xs { width: 1rem; height: 1rem; border-width: 0.2em; }
      .action-spinner { border: 0.2em solid #fff; border-right-color: transparent; margin-top: 2px; margin-left: 5px; }
      .dropdown-menu { background-color: #ffffffc9; border: 1px solid rgb(88 88 88 / 15%); }
      .datepicker-here { height: 250px; }
      .datepicker--cell.-selected-, .datepicker--cell.-selected-.-current-,.datepicker--cell.-selected-.-focus- { background: #4e4e4e; }
      .query { font-size: 15px; height: 30px; width: 100%; display: flex; align-items: center; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; padding: 0px 15px 0px 15px; cursor: pointer; border-top: solid 1px #e3e3e3; }
      .query-h { width: 100%; height: 40px; display: flex; align-items: center; background-color: #efefef; padding: 0px 15px 0px 15px; }
      .selected { background-color: #525252; color: white; }
      .q-date { flex-shrink: 0; white-space: nowrap; }
      .q-text { flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; padding-left: 5px; }
      .fs-7 { font-size: 12px; }
      .queries-tm { height: 400px; overflow-y: scroll; border: 1px solid #e3e3e3; }

      /* DB Manager specific styles */
      .db-manager-layout { display: flex; height: calc(100vh - 170px); /* Adjust as needed */ }
      .db-sidebar { width: 260px; flex-shrink: 0; background-color: #f8f9fa; padding: 1rem; overflow-y: auto; border-right: 1px solid #dee2e6; }
      .db-content { flex-grow: 1; padding: 1rem; overflow-y: auto; background-color: #ffffff; display: flex; flex-direction: column; }
      .list-group-item { cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
      .list-group-item.active { background-color: #4e4e4e; border-color: #4e4e4e; color: white; }
      .table-responsive-manager { flex-grow: 1; overflow: auto; /* Let table area grow */ }
      .table thead th { position: sticky; top: 0; background: white; z-index: 1; }
      .table td, .table th { white-space: nowrap; /* Prevent wrapping in cells */ }
      .table td { max-width: 300px; overflow: hidden; text-overflow: ellipsis; } /* Truncate long cell content */
      .action-buttons span { cursor: pointer; margin-left: 8px; }
      .sidebar-item-actions { display: none; /* Hide by default */ }
      .list-group-item:hover .sidebar-item-actions { display: inline-block; /* Show on hover */ }
      .btn-xs { padding: 0.1rem 0.3rem; font-size: 0.75rem; }
      .modal-body .form-control { margin-bottom: 0.5rem; }
      .query-results-table { max-height: 400px; overflow: auto; } /* Limit height of query results */
      .db-content-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-shrink: 0; }
      .pagination-controls { flex-shrink: 0; /* Prevent pagination from shrinking */ margin-top: 1rem; }
  </style>
</head>
<body>
  <div id="app">
    <navbar @navigate="navigateTo" @logout="logout" :active-page="currentPage"></navbar>

    <main :class="{'container-fluid mt-3': currentPage !== 'container-fluid mt-3'}">
        <dashboard-page v-if="currentPage === 'dashboard'" :api-url="apiUrl" :port="port"></dashboard-page>
        <time-machine-page v-if="currentPage === 'time-machine'" :api-url="apiUrl" @show-confirm="showConfirmModal"></time-machine-page>
        <backup-restore-page ref="backupRestorePageRef" v-if="currentPage === 'backup-restore'" :api-url="apiUrl" @show-confirm="showConfirmModal" @show-upload="showUploadModal"></backup-restore-page>
        <manage-database-page
            v-if="currentPage === 'manage-database'"
            :api-url="apiUrl"
            :base-api-path="dbManagerApiPath"
            @show-confirm="showConfirmModal"
            ref="manageDatabasePageRef"
        ></manage-database-page>

        <div v-if="!validPages.includes(currentPage)" class="card container-fluid mt-3">
             <div class="card-body"> <h5 class="card-title">Page Not Implemented</h5> <p class="card-text">The '{{ currentPage }}' page is not yet available.</p> </div>
        </div>
    </main>

    <footer class="mt-3 pb-3 text-center text-light small thin">
        <span>Â© InFlux Technologies</span> <span id="build_version">v1.7.3</span>
    </footer>

    <confirm-modal ref="confirmModal" @confirmed="handleConfirmation"></confirm-modal>
    <upload-modal ref="uploadModal" :api-url="apiUrl" @upload-complete="refreshBackupList"></upload-modal>
    </div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/air-datepicker/2.2.3/js/datepicker.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/air-datepicker/2.2.3/js/i18n/datepicker.en.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

<script>
    const { createApp, ref, reactive, onMounted, computed, nextTick, watch } = Vue;

    // --- Root Vue App ---
    const app = createApp({
        data() {
            return {
                currentPage: 'dashboard',
                apiUrl: '',
                port: '',
                dbManagerApiPath: '/api/db-manager',
                lock: false,
                confirmCallback: null,
                confirmParam: null,
                confirmMessage: '',
                // Updated valid pages list
                validPages: ['dashboard', 'time-machine', 'backup-restore', 'manage-database', 'backlog-editor', 'run-query', 'logs', 'settings']
            }
        },
        methods: {
            navigateTo(page) {
                 if (this.lock) return;
                if (!this.validPages.includes(page)) {
                     console.warn(`Navigation to invalid page "${page}" blocked.`);
                     this.currentPage = 'dashboard';
                     window.location.hash = 'dashboard';
                     return;
                }
                this.currentPage = page;
                window.location.hash = page;
                 if (page === 'backup-restore') {
                    nextTick(() => {
                         const backupRestoreComponent = this.$refs.backupRestorePageRef;
                         if (backupRestoreComponent?.fetchBackupFiles) {
                             backupRestoreComponent.fetchBackupFiles();
                         } else { console.warn("Could not find BackupRestorePage component instance via ref to refresh."); }
                    });
                }
            },
            logout() {
                axios.get(`${this.apiUrl}/logout`)
                    .then(response => {
                        if (response.data === 'OK') { window.location.replace(this.apiUrl || '/'); }
                        else { console.error("Logout failed:", response.data); alert("Logout failed."); }
                    })
                    .catch(error => { console.error("Error during logout:", error); alert("An error occurred during logout."); });
            },
            showConfirmModal(payload) {
                this.confirmMessage = payload.message;
                this.confirmCallback = payload.callback;
                this.confirmParam = payload.param;
                this.$refs.confirmModal.show(this.confirmMessage);
            },
            showUploadModal() {
                 this.$refs.uploadModal.show();
             },
            handleConfirmation() {
                 if (typeof this.confirmCallback === 'function') { this.confirmCallback(this.confirmParam); }
                 else { console.error("Confirmation callback is not a function:", this.confirmCallback); }
                 this.confirmCallback = null; this.confirmParam = null;
             },
            refreshBackupList() {
                const backupPageComponent = this.$refs.backupRestorePageRef;
                if (backupPageComponent?.fetchBackupFiles) { backupPageComponent.fetchBackupFiles(); }
                else { console.warn("Could not trigger backup list refresh via ref."); }
             },
            initialize() {
                let baseUrl = new URL(window.location.href);
                this.apiUrl = baseUrl.protocol + '//' + baseUrl.hostname + ':' + baseUrl.port;
                this.port = baseUrl.port;
                let fragment = baseUrl.hash;
                if (fragment && fragment.length > 1) {
                    const pageFromHash = fragment.substring(1);
                    if (this.validPages.includes(pageFromHash)) { this.currentPage = pageFromHash; }
                    else { this.currentPage = 'dashboard'; window.location.hash = 'dashboard'; }
                } else { this.currentPage = 'dashboard'; window.location.hash = 'dashboard'; }
                window.addEventListener('hashchange', () => {
                    const newPage = window.location.hash.substring(1);
                     if (this.validPages.includes(newPage)) { this.navigateTo(newPage); }
                     else if (newPage === '') { this.navigateTo('dashboard'); }
                     else { this.navigateTo('dashboard'); }
                });
                // Add interceptor for auth errors (optional but good practice)
                axios.interceptors.response.use(response => response, error => {
                    if (error.response && error.response.status === 401) {
                        console.warn('Unauthorized request detected, redirecting to login.');
                        // Assuming logout clears session/cookie and redirects
                        this.logout();
                        // Or directly redirect: window.location.replace(this.apiUrl || '/');
                    }
                    return Promise.reject(error);
                });
            }
        },
        mounted() { this.initialize(); }
    });

    // --- Navbar Component ---
    app.component('navbar', {
        props: ['activePage'], emits: ['navigate', 'logout'],
        template: `
            <nav class="navbar navbar-expand-lg navbar-dark">
                <div class="container-fluid">
                    <a class="navbar-brand clickable" @click.prevent="$emit('navigate', 'dashboard')"> <span style="font-size: 28px;font-weight: 600;line-height: 10px;margin-left: -5px;color: #ffd600;">DB</span> <span style="letter-spacing: -1px;font-weight: 100;">Control Panel</span> </a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                            <li class="nav-item"> <a class="nav-link" :class="{ active: activePage === 'dashboard' }" href="#dashboard" @click.prevent="$emit('navigate', 'dashboard')"><i class="fas fa-tachometer-alt"></i>Dashboard</a> </li>
                            <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownDB" role="button" data-bs-toggle="dropdown" aria-expanded="false"> <i class="fas fa-database"></i>DB </a>
                                <ul class="dropdown-menu" aria-labelledby="navbarDropdownDB">
                                    <!-- <li><a class="dropdown-item" :class="{ active: activePage === 'time-machine' }" href="#time-machine" @click.prevent="$emit('navigate', 'time-machine')"><i class="fas fa-history"></i>Point-in-time Recovery</a></li> -->
                                    <li><a class="dropdown-item" :class="{ active: activePage === 'backup-restore' }" href="#backup-restore" @click.prevent="$emit('navigate', 'backup-restore')"><i class="fas fa-cloud-upload-alt"></i>Backup &amp; Restore</a></li>
                                    <li><a class="dropdown-item" :class="{ active: activePage === 'manage-database' }" href="#manage-database" @click.prevent="$emit('navigate', 'manage-database')"><i class="fas fa-edit"></i>Manage Database</a></li>
                                </ul>
                            </li>
                        </ul>
                        <button class="btn btn-outline-light" @click="$emit('logout')">Log Out</button>
                    </div>
                </div>
            </nav> `
     });
        // --- Dashboard Page Component ---
        app.component('dashboard-page', {
            props: ['apiUrl', 'port'],
            data() {
                return {
                    nodes: [],
                    isLoading: false,
                    error: null,
                    dbEngine: 'MYSQL 8' // Or fetch dynamically if needed
                }
            },
            methods: {
                async fetchNodeStatus(ip) {
                    try {
                        // Construct URL carefully, ensuring port is included
                        const statusUrl = `https://api.allorigins.win/raw?url=http://${ip}:${this.port}/status`;
                        // console.log(`Fetching status from: ${statusUrl}`); // Debugging
                        const response = await axios.get(statusUrl, { timeout: 4000 });
                        return response.data; // { sequenceNumber, masterIP, status, taskStatus }
                    } catch (err) {
                        console.error(`Error fetching status for node ${ip}:`, err.message);
                        // Provide a clearer error status
                        return { status: `Error (${err.code || 'Timeout'})`, sequenceNumber: 'N/A', masterIP: 'N/A' };
                    }
                },
                async fetchClusterStats() {
                    this.isLoading = true;
                    this.error = null;
                    this.nodes = []; // Clear previous nodes
                    try {
                        const response = await axios.get(`${this.apiUrl}/nodelist`, { timeout: 3000 });
                        if (Array.isArray(response.data)) {
                            const nodePromises = response.data.map(async (node, index) => {
                                const statusData = await this.fetchNodeStatus(node.ip);
                                let displayStatus = statusData.status;
                                if (displayStatus === 'COMPRESSING' && statusData.taskStatus !== undefined) {
                                    displayStatus += ` ${statusData.taskStatus}%`;
                                }
                                return {
                                    id: index + 1,
                                    ip: node.ip,
                                    sequenceNumber: statusData.sequenceNumber,
                                    masterIP: statusData.masterIP,
                                    status: displayStatus
                                };
                            });
                            this.nodes = await Promise.all(nodePromises);
                        } else {
                             throw new Error("Invalid data format received for nodelist.");
                        }
                    } catch (err) {
                        console.error("Error fetching cluster stats:", err);
                        this.error = `Failed to load cluster stats: ${err.message}`;
                    } finally {
                        this.isLoading = false;
                    }
                }
            },
            mounted() {
                this.fetchClusterStats();
                // Optional: Set up an interval to refresh stats
                // this.intervalId = setInterval(this.fetchClusterStats, 15000); // Refresh every 15 seconds
            },
            // beforeUnmount() {
            //     // Clear interval when component is destroyed
            //     if (this.intervalId) {
            //         clearInterval(this.intervalId);
            //     }
            // },
            template: `
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h3 class="m-0"><i class="fas fa-tachometer-alt"></i> Cluster Stats</h3>
                        <span class="fs-5">DB Engine: {{ dbEngine }}</span>
                    </div>
                    <div class="card-body">
                        <div v-if="isLoading" class="d-flex justify-content-center">
                            <div class="spinner-border text-info" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                        <div v-if="error" class="alert alert-danger">{{ error }}</div>
                        <div v-if="!isLoading && !error">
                            <h5>Active Nodes:</h5>
                            <table class="table table-bordered table-hover">
                                <thead>
                                    <tr>
                                        <th scope="col" width="10">#</th>
                                        <th scope="col" width="200">IP</th>
                                        <th scope="col" width="200">Sequence Number</th>
                                        <th scope="col" width="200">Master IP</th>
                                        <th scope="col">Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-if="nodes.length === 0">
                                        <td colspan="5" class="text-center">No active nodes found.</td>
                                    </tr>
                                    <tr v-for="node in nodes" :key="node.ip">
                                        <th scope="row">{{ node.id }}</th>
                                        <td>{{ node.ip }}</td>
                                        <td>{{ node.sequenceNumber }}</td>
                                        <td>{{ node.masterIP }}</td>
                                        <td>{{ node.status }}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `
        });

        // --- Time Machine Page Component ---
        app.component('time-machine-page', {
             props: ['apiUrl'],
             emits: ['show-confirm'], // Declare emitted events
             data() {
                 return {
                     selectedDate: null,
                     queries: [],
                     selectedQuerySeq: null,
                     isLoadingQueries: false,
                     isRewinding: false,
                     rewindSuccess: false,
                     rewindError: null,
                     datePickerInstance: null,
                     totalRecords: 0,
                 }
             },
             methods: {
                 initializeDatePicker(minDate, maxDate) {
                     // Ensure jQuery is available and the element exists
                     if (typeof $ !== 'undefined' && this.$refs.datepickerContainer) {
                         this.datePickerInstance = $(this.$refs.datepickerContainer).datepicker({
                             language: 'en',
                             inline: true,
                             minDate: minDate ? new Date(minDate) : null,
                             maxDate: maxDate ? new Date(maxDate) : null,
                             onSelect: (formattedDate, date, inst) => {
                                 if (date) {
                                     this.selectedDate = date;
                                     this.fetchLogsForDate(date);
                                     this.selectedQuerySeq = null; // Reset selection
                                     this.rewindSuccess = false; // Reset status
                                     this.rewindError = null;
                                 }
                             }
                         }).data('datepicker');
                     } else {
                         console.error("jQuery or datepicker container not found for initialization.");
                     }
                 },
                 async fetchDateRange() {
                     try {
                         const response = await axios.get(`${this.apiUrl}/getLogDateRange`);
                         this.initializeDatePicker(response.data.min_timestamp, response.data.max_timestamp);
                     } catch (error) {
                         console.error("Error fetching date range:", error);
                         // Initialize datepicker without range limits if API fails
                         this.initializeDatePicker(null, null);
                     }
                 },
                 async fetchLogsForDate(date) {
                     if (!date) return;
                     this.isLoadingQueries = true;
                     this.queries = [];
                     this.totalRecords = 0;
                     const timestamp = Math.floor(date.getTime());
                     // Fetch logs for the entire day (adjust length as needed)
                     const startTime = new Date(date);
                     startTime.setHours(0, 0, 0, 0);
                     const endTime = new Date(date);
                     endTime.setHours(23, 59, 59, 999);
                     try {
                         const response = await axios.get(`${this.apiUrl}/getLogsByTime?starttime=${startTime.getTime()}&length=${endTime.getTime() - startTime.getTime()}`);
                         let points = 0;
                         const relevantQueries = [];
                         const rawData = response.data; // Assuming response.data is the array

                         for (let i = 0; i < rawData.length; i++) {
                             if (rawData[i].query && rawData[i].query.toLowerCase().startsWith('set sess')) {
                                 points++;
                                 let ops = 1;
                                 let currentSeq = rawData[i].seq; // Capture the seq of the 'set sess' query
                                 let timestamp = rawData[i].timestamp; // Capture the timestamp

                                 // Count operations until the next 'set sess' or end of data
                                 let j = i + 1;
                                 while (j < rawData.length && (!rawData[j].query || !rawData[j].query.toLowerCase().startsWith('set sess'))) {
                                     ops++;
                                     j++;
                                 }

                                 relevantQueries.push({
                                     seq: currentSeq,
                                     timestamp: timestamp,
                                     ops: ops,
                                     displayTime: new Date(timestamp).toLocaleString()
                                 });
                                 i = j - 1; // Move the outer loop index forward
                             }
                         }
                         this.queries = relevantQueries;
                         this.totalRecords = points;

                     } catch (error) {
                         console.error("Error fetching logs:", error);
                         this.queries = []; // Clear queries on error
                         this.totalRecords = 0;
                     } finally {
                         this.isLoadingQueries = false;
                     }
                 },
                 selectQuery(seq) {
                     if (this.isRewinding) return; // Prevent selection change during rewind
                     this.selectedQuerySeq = seq;
                     this.rewindSuccess = false; // Reset status
                     this.rewindError = null;
                 },
                 confirmRewind() {
                     if (!this.selectedQuerySeq) {
                         alert("Please select a recovery point first.");
                         return;
                     }
                      // Emit an event to the parent to show the confirmation modal
                      this.$emit('show-confirm', {
                          message: `<span><i class="fas fa-exclamation-triangle text-danger"></i> This action is irreversible. Are you sure you want to rewind to sequence ${this.selectedQuerySeq}?</span>`,
                          callback: this.executeRewind, // Pass the actual rewind method
                          param: this.selectedQuerySeq   // Pass the sequence number
                      });
                 },
                 async executeRewind(seq) {
                     if (!seq) return; // Safety check

                     this.isRewinding = true;
                     this.rewindSuccess = false;
                     this.rewindError = null;
                     this.$root.lock = true; // Use root lock state if needed globally

                     try {
                         const response = await axios.post(`${this.apiUrl}/rollback`, { seqNo: seq });
                         console.log('Rewind response:', response.data);
                         this.rewindSuccess = true;
                         // Optionally re-fetch logs or update UI state after successful rewind
                         if (this.selectedDate) {
                            this.fetchLogsForDate(this.selectedDate); // Refresh logs for the current date
                         }
                         this.selectedQuerySeq = null; // Deselect after rewind
                     } catch (error) {
                         console.error("Error during rewind:", error);
                         this.rewindError = `Rewind failed: ${error.response?.data || error.message}`;
                         this.rewindSuccess = false;
                     } finally {
                         this.isRewinding = false;
                         this.$root.lock = false; // Release lock
                     }
                 }
             },
             mounted() {
                 this.fetchDateRange(); // Fetch range and initialize datepicker
             },
             beforeUnmount() {
                 // Clean up datepicker instance if it exists
                 if (this.datePickerInstance) {
                     this.datePickerInstance.destroy();
                 }
             },
            computed: {
                rewindButtonDisabled() {
                    return !this.selectedQuerySeq || this.isRewinding;
                }
            },
             template: `
                <div class="card">
                    <div class="card-header">
                        <h3 class="m-0"><i class="fas fa-history"></i> Point-in-time Recovery</h3>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-xxl-3 col-xl-12 mb-3 mb-xxl-0">
                                <p class="text-secondary fs-5">1. Choose a Date</p>
                                <div ref="datepickerContainer" class="datepicker-here"></div>
                            </div>

                            <div class="col-xxl-7 col-xl-12 mb-3 mb-xxl-0">
                                <p class="text-secondary fs-5">2. Choose Recovery Point</p>
                                <div class="queries-tm">
                                    <div class="query-h">
                                        <span class="q-text">Total <b>{{ totalRecords }}</b> sessions found for selected date</span>
                                        <span class="q-date">Date and Time</span>
                                    </div>
                                    <div v-if="isLoadingQueries" class="text-center p-3">
                                        <div class="spinner-border spinner-border-sm" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                    </div>
                                    <div v-else-if="queries.length === 0 && selectedDate" class="text-center p-3 text-muted">
                                        No recovery points found for this date.
                                    </div>
                                     <div v-else-if="!selectedDate" class="text-center p-3 text-muted">
                                         Please select a date.
                                     </div>
                                    <div v-else>
                                        <div v-for="query in queries" :key="query.seq"
                                             class="query"
                                             :class="{ 'selected': query.seq === selectedQuerySeq }"
                                             @click="selectQuery(query.seq)">
                                             <span class="q-text"><i class="fas fa-circle text-warning me-2"></i> Seq: {{ query.seq }}</span>
                                             <span class="q-date">{{ query.ops }} Ops - {{ query.displayTime }}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="col-xxl-2 col-xl-12">
                                <p class="text-secondary fs-5">3. Rewind</p>
                                <button type="button" class="btn btn-dark w-100" @click="confirmRewind" :disabled="rewindButtonDisabled">
                                    <i class="fas fa-history"></i> Rewind Database
                                </button>
                                <p class="text-secondary fs-7 mt-2">Caution! This action is irreversible and will permanently rewind your database to the selected point. All data after this point will be lost.</p>

                                <div v-if="isRewinding" class="mt-2 d-flex align-items-center">
                                    <div class="spinner-border spinner-border-xs me-2" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <span>Rewind in progress, please wait...</span>
                                </div>
                                <div v-if="rewindSuccess && !isRewinding" class="mt-2 text-success">
                                    <span><i class="fas fa-check-double me-1"></i> Rewind Finished Successfully!</span>
                                </div>
                                 <div v-if="rewindError && !isRewinding" class="mt-2 text-danger">
                                     <span><i class="fas fa-times-circle me-1"></i> {{ rewindError }}</span>
                                 </div>
                            </div>
                        </div>
                    </div>
                </div>
             `
         });

        // --- Backup & Restore Page Component ---
        app.component('backup-restore-page', {
             props: ['apiUrl'],
             emits: ['show-confirm', 'show-upload'],
             data() {
                 return {
                     backupFiles: [],
                     isLoading: false,
                     error: null,
                     generatingBackup: false,
                     executingBackup: null, // Store filename being executed
                     importInProgress: false, // General flag
                     restoreProgress: 0, // Current restore progress percentage (0-100)
                     statusCalls: 0,
                     statusIntervalId: null,
                 }
             },
             methods: {
                 async fetchBackupFiles() {
                     this.isLoading = true;
                     this.error = null;
                     try {
                         const response = await axios.get(`${this.apiUrl}/listbackups`, { timeout: 5000 });
                         if (Array.isArray(response.data)) {
                             this.backupFiles = response.data.map((file, index) => ({
                                 id: index + 1,
                                 ...file,
                                 fileNameWithoutExt: file.fileName.split('.')[0] // For actions
                             }));
                         } else {
                             this.backupFiles = [];
                             console.warn("Received non-array data for backup list:", response.data);
                         }
                     } catch (err) {
                         console.error("Error fetching backup files:", err);
                         this.error = `Failed to load backup files: ${err.message}`;
                         this.backupFiles = [];
                     } finally {
                         this.isLoading = false;
                     }
                 },
                 async generateBackup() {
                     if (this.generatingBackup) return;
                     this.generatingBackup = true;
                     this.error = null; // Clear previous errors
                     try {
                         // Add a small delay for user feedback if needed
                         // await new Promise(resolve => setTimeout(resolve, 500));
                         await axios.post(`${this.apiUrl}/generatebackup`, {}, { timeout: 60000 }); // Increased timeout for generation
                         // Wait a bit before refreshing the list
                         await new Promise(resolve => setTimeout(resolve, 1500));
                         await this.fetchBackupFiles(); // Refresh list after generation
                     } catch (err) {
                         console.error("Error generating backup:", err);
                         this.error = `Failed to generate backup: ${err.response?.data || err.message}`;
                     } finally {
                         this.generatingBackup = false;
                     }
                 },
                 confirmDelete(filename) {
                      this.$emit('show-confirm', {
                          message: `<span><i class="fas fa-exclamation-triangle text-danger"></i> This action is irreversible. Are you sure you want to delete the backup file <strong>${filename}.sql</strong>?</span>`,
                          callback: this.executeDelete,
                          param: filename
                      });
                 },
                 async executeDelete(filename) {
                     this.error = null;
                     try {
                         await axios.post(`${this.apiUrl}/deletebackup`, { filename }, { timeout: 5000 });
                         await this.fetchBackupFiles(); // Refresh list
                     } catch (err) {
                         console.error("Error deleting backup:", err);
                         this.error = `Failed to delete backup ${filename}.sql: ${err.response?.data || err.message}`;
                     }
                 },
                 confirmExecute(filename) {
                     if (this.importInProgress) {
                         alert("Another import/restore operation is already in progress.");
                         return;
                     }
                      this.$emit('show-confirm', {
                          message: `<span><i class="fas fa-exclamation-triangle text-danger"></i> This action is irreversible and may overwrite existing data. Are you sure you want to restore the backup file <strong>${filename}.sql</strong>?</span>`,
                          callback: this.executeBackup,
                          param: filename
                      });
                 },
                 async executeBackup(filename) {
                    if (this.importInProgress) return; // Double check

                    this.executingBackup = filename; // Mark which file is executing
                    this.restoreProgress = 0;     // Reset progress
                    this.error = null;            // Clear previous errors
                    this.statusCalls = 0;

                    // Start polling for status
                    if (this.statusIntervalId) {
                        clearInterval(this.statusIntervalId); // Clear any existing interval
                    }
                    this.statusIntervalId = setInterval(this.checkRestoreStatus, 3000); // Poll every 3 seconds

                    try {
                      if(!this.importInProgress){
                          this.importInProgress = true;
                          // Call /executebackup with an extended timeout (e.g., 1 hour = 3600000 ms)
                          await axios.post(`${this.apiUrl}/executebackup`, { filename }, { timeout: 3600000 }); 
                          alert(`Backup file ${filename}.sql restored successfully.`);
                        }
                    } catch (err) {
                        if(this.restoreProgress !== 0){
                          this.importInProgress = false;
                          console.error("Error executing backup:", err);
                          this.error = `Failed to restore backup ${filename}.sql: ${err.response?.data?.message || err.response?.data || err.message}`;
                          alert(`Error executing backup ${filename}.sql: ${this.error}`); 
                        }
                    } finally {
                      if(this.restoreProgress !== 0){
                          // Stop polling and reset state
                          if (this.statusIntervalId) {
                              clearInterval(this.statusIntervalId);
                              this.statusIntervalId = null;
                          }
                          this.executingBackup = null;
                          this.importInProgress = false;
                          this.restoreProgress = 0; // Reset progress for the next operation
                          await this.fetchBackupFiles(); // Refresh list regardless of outcome
                      }
                    }
                },
                async checkRestoreStatus() {
                    this.statusCalls += 1;
                    if (this.statusCalls < 3) return;
                    if (!this.executingBackup) { // Stop if no backup is being executed
                        if (this.statusIntervalId) {
                            clearInterval(this.statusIntervalId);
                            this.statusIntervalId = null;
                        }
                        return;
                    }
                    try {
                        const response = await axios.get(`${this.apiUrl}/status`, { timeout: 2500 }); // Short timeout for status check
                        if (response.data && response.data.taskStatus !== undefined) {
                            const taskStatus = response.data.taskStatus;
                            console.log(taskStatus);
                            if (taskStatus >= 0 && taskStatus <= 100) {
                                this.restoreProgress = taskStatus;
                            } else if (taskStatus === -1) {
                                if (this.statusIntervalId) {
                                    clearInterval(this.statusIntervalId); // Stop polling
                                    this.statusIntervalId = null;
                                }
                                this.executingBackup = null;
                                this.importInProgress = false;
                                this.restoreProgress = 0; // Reset progress for the next operation
                                await this.fetchBackupFiles(); // Refresh list regardless of outcome
                            }
                        }
                    } catch (err) {
                        console.warn("Error fetching restore status:", err.message);
                        // Optionally, stop polling after a few errors, or let executeBackup's finally handle it.
                    }
                },
                 getDownloadUrl(filename) {
                     return `${this.apiUrl}/getbackupfile/${filename}`;
                 },
                 triggerUploadModal() {
                     this.$emit('show-upload');
                 }
             },
             mounted() {
                 this.fetchBackupFiles();
             },
             beforeUnmount() {
                // Clear interval when component is destroyed to prevent memory leaks
                if (this.statusIntervalId) {
                    clearInterval(this.statusIntervalId);
                }
            },
             template: `
        <div class="card">
            <div class="card-header">
                <h3 class="m-0"><i class="fas fa-cloud-upload-alt"></i> Backup and Restore</h3>
            </div>
            <div class="card-body">
                <div v-if="error" class="alert alert-danger">{{ error }}</div>

                <div class="d-flex justify-content-between align-items-center p-2 mb-3 border-bottom">
                    <h5>Local Backup Files:</h5>
                    <div>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" @click="generateBackup" :disabled="generatingBackup || importInProgress">
                            <span v-if="generatingBackup" class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                            <i v-else class="fas fa-plus me-1"></i>
                            {{ generatingBackup ? 'Generating...' : 'Generate New Backup' }}
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" @click="triggerUploadModal" :disabled="generatingBackup || importInProgress">
                            <i class="fas fa-upload me-1"></i> Upload Backup File
                        </button>
                    </div>
                </div>

                <div v-if="isLoading" class="d-flex justify-content-center my-4">
                    <div id="backup-file-list-spinner" class="spinner-border text-info" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>

                <table v-else class="table table-hover table-bordered align-middle">
                    <thead>
                        <tr>
                            <th scope="col" width="10">#</th>
                            <th scope="col" width="300">Name</th>
                            <th scope="col" width="150">File Size</th>
                            <th scope="col" width="250">Date & Time</th>
                            <th scope="col">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-if="backupFiles.length === 0">
                            <td colspan="5" class="text-center text-muted">No backup files found.</td>
                        </tr>
                        <tr v-for="file in backupFiles" :key="file.fileName">
                            <th scope="row">{{ file.id }}</th>
                            <td>{{ file.fileName }}</td>
                            <td>{{ file.fileSize }}</td>
                            <td>{{ file.createdDateTime }}</td>
                            <td>
                                <a class="btn btn-sm btn-success me-1" :href="getDownloadUrl(file.fileNameWithoutExt)" target="_blank" :disabled="importInProgress">
                                    <i class="fas fa-download"></i> Download
                                </a>
                                <button class="btn btn-sm btn-danger me-1" @click="confirmDelete(file.fileNameWithoutExt)" :disabled="importInProgress || executingBackup === file.fileNameWithoutExt">
                                    <i class="fas fa-trash"></i> Delete
                                </button>

                                <button class="btn btn-sm btn-dark" @click="confirmExecute(file.fileNameWithoutExt)" 
                                        :disabled="importInProgress || generatingBackup">
                                    <template v-if="executingBackup === file.fileNameWithoutExt">
                                        <span v-if="statusIntervalId && restoreProgress >= 0 && restoreProgress < 100">
                                            Restoring ({{ restoreProgress }}%)
                                        </span>
                                        <span v-else-if="statusIntervalId && restoreProgress === 100">
                                            Finalizing
                                        </span>
                                        <span v-else> Restoring
                                        </span>
                                        <span class="spinner-border spinner-border-xs action-spinner ms-1" role="status" aria-hidden="true"></span>
                                    </template>
                                    <template v-else>
                                        <i class="fas fa-play"></i> Restore
                                    </template>
                                </button>
                                </td>
                        </tr>
                    </tbody>
                </table>
                <p>
                    Notice: Deleting backup files may disrupt database replication. Refrain from deleting any files unless you are fully aware of the consequences.
                </p>
            </div>
        </div>
    `
         });

        // --- Confirm Modal Component ---
        app.component('confirm-modal', {
             emits: ['confirmed'],
             data() {
                 return {
                     modalInstance: null,
                     message: 'Are you sure?', // Default message
                     isLoading: false
                 }
             },
             methods: {
                 show(message) {
                     this.message = message || 'Are you sure?';
                     this.isLoading = false; // Reset loading state
                     if (this.modalInstance) {
                         this.modalInstance.show();
                     }
                 },
                 hide() {
                     if (this.modalInstance) {
                         this.modalInstance.hide();
                     }
                 },
                 confirmAction() {
                     this.isLoading = true; // Show loading state on 'Yes' button
                     // Introduce a small delay for visual feedback if needed,
                     // otherwise the parent handles the actual async logic.
                     setTimeout(() => {
                         this.$emit('confirmed');
                         // Consider hiding the modal immediately or letting the parent hide it after the action
                         this.hide();
                         this.isLoading = false; // Reset loading state after emitting
                     }, 100); // Small delay
                 }
             },
             mounted() {
                 // Initialize Bootstrap modal instance
                 const modalElement = this.$refs.modal;
                 if (modalElement && typeof bootstrap !== 'undefined') {
                     this.modalInstance = new bootstrap.Modal(modalElement);
                 } else {
                     console.error("Bootstrap modal could not be initialized.");
                 }
             },
             template: `
                <div class="modal fade" ref="modal" tabindex="-1" aria-labelledby="confirmModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-dialog-centered">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="confirmModalLabel">Confirmation</h5>
                                <button type="button" class="btn-close" @click="hide" aria-label="Close" :disabled="isLoading"></button>
                            </div>
                            <div class="modal-body text-center">
                                <div v-html="message"></div>
                                <div v-if="isLoading" class="mt-3">
                                     <div class="spinner-border spinner-border-sm" role="status">
                                         <span class="visually-hidden">Loading...</span>
                                     </div>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-light" @click="hide" :disabled="isLoading">No</button>
                                <button type="button" class="btn btn-dark" @click="confirmAction" :disabled="isLoading">
                                     <span v-if="isLoading" class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                                     Yes
                                 </button>
                            </div>
                        </div>
                    </div>
                </div>
             `
         });

        // --- Upload Modal Component ---
        app.component('upload-modal', {
             props: ['apiUrl'],
             emits: ['upload-complete'],
             data() {
                 return {
                     modalInstance: null,
                     selectedFile: null,
                     uploadStatus: '',
                     isUploading: false,
                 }
             },
             methods: {
                 show() {
                     this.reset();
                     if (this.modalInstance) {
                         this.modalInstance.show();
                     }
                 },
                 hide() {
                     if (this.modalInstance) {
                         this.modalInstance.hide();
                     }
                 },
                 handleFileChange(event) {
                     this.selectedFile = event.target.files[0];
                     this.uploadStatus = this.selectedFile ? `Selected: ${this.selectedFile.name}` : 'Please select an SQL file.';
                 },
                 async uploadFile() {
                     if (!this.selectedFile) {
                         this.uploadStatus = 'Please select an SQL file first.';
                         return;
                     }
                     if (!this.selectedFile.name.toLowerCase().endsWith('.sql')) {
                         this.uploadStatus = 'Error: Please select a valid .sql file.';
                         return;
                     }

                     this.isUploading = true;
                     this.uploadStatus = 'Uploading...';

                     const formData = new FormData();
                     formData.append('sqlFile', this.selectedFile);

                     try {
                         const response = await axios.post(`${this.apiUrl}/upload-sql`, formData, {
                             headers: {
                                 'Content-Type': 'multipart/form-data'
                             },
                             timeout: 120000 // Timeout for upload
                         });
                         this.uploadStatus = `Success: ${response.data}`;
                         this.$emit('upload-complete'); // Notify parent
                         // Optionally close modal after a short delay on success
                         setTimeout(() => this.hide(), 1500);
                     } catch (error) {
                         console.error("Upload error:", error);
                         this.uploadStatus = `Error: ${error.response?.data || error.message}`;
                     } finally {
                         this.isUploading = false;
                     }
                 },
                 reset() {
                     this.selectedFile = null;
                     this.uploadStatus = 'Please select an SQL file.';
                     this.isUploading = false;
                     // Reset the file input visually if possible
                     const fileInput = this.$refs.sqlFileInput;
                     if(fileInput) {
                         fileInput.value = '';
                     }
                 }
             },
             mounted() {
                 const modalElement = this.$refs.modal;
                 if (modalElement && typeof bootstrap !== 'undefined') {
                     this.modalInstance = new bootstrap.Modal(modalElement);
                     // Reset state when modal is hidden
                     modalElement.addEventListener('hidden.bs.modal', this.reset);
                 } else {
                     console.error("Bootstrap modal could not be initialized for upload.");
                 }
             },
             beforeUnmount() {
                 // Clean up event listener
                 const modalElement = this.$refs.modal;
                 if (modalElement) {
                     modalElement.removeEventListener('hidden.bs.modal', this.reset);
                 }
             },
             template: `
                <div class="modal fade" ref="modal" tabindex="-1" aria-labelledby="uploadModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-dialog-centered">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="uploadModalLabel">Upload Backup SQL File</h5>
                                <button type="button" class="btn-close" @click="hide" aria-label="Close" :disabled="isUploading"></button>
                            </div>
                            <div class="modal-body">
                                <div class="mb-3">
                                    <label for="sqlFile" class="form-label">Select an .sql file:</label>
                                    <input type="file" class="form-control" id="sqlFile" ref="sqlFileInput" @change="handleFileChange" accept=".sql" :disabled="isUploading">
                                </div>
                                <div class="d-flex justify-content-end mb-2">
                                    <button class="btn btn-dark" @click="uploadFile" :disabled="isUploading || !selectedFile">
                                        <span v-if="isUploading" class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                                        {{ isUploading ? 'Uploading...' : 'Upload' }}
                                    </button>
                                </div>
                                <div id="uploadStatus" class="mt-2 text-muted small">{{ uploadStatus }}</div>
                            </div>
                        </div>
                    </div>
                </div>
             `
         });



        // --- Manage Database Page Component (NEW) ---
        app.component('manage-database-page', {
            props: ['apiUrl', 'baseApiPath'],
            emits: ['show-confirm'], // To use the root confirm modal
            data() {
                return {
                    databases: [],
                    tables: [],
                    rows: [],
                    columns: [],
                    selectedDatabase: null,
                    selectedTable: null,
                    isLoadingDatabases: false,
                    isLoadingTables: false,
                    isLoadingRows: false,
                    error: null,
                    // Pagination state
                    currentPage: 1,
                    rowsPerPage: 50, // Default rows per page
                    totalRows: 0,
                    // Editing state
                    editingRow: null, // Holds the row data being edited
                    editingRowIndex: null, // Index of the row being edited
                    primaryKeyColumn: null, // Name of the primary key column (auto-detect or assume first)
                    // Custom query state
                    customQuery: '',
                    queryResult: null,
                    queryError: null,
                    isQueryRunning: false,
                    queryResultType: 'none', // 'rows', 'affected', 'error'
                    // Modal instances (will be initialized in mounted)
                    editModalInstance: null,
                    queryModalInstance: null
                }
            },
            computed: {
                totalPages() {
                    if (this.totalRows === 0 || this.rowsPerPage <= 0) return 1;
                    return Math.ceil(this.totalRows / this.rowsPerPage);
                }
            },
            methods: {
                getApiPath(endpoint) {
                    const apiBase = this.baseApiPath.endsWith('/') ? this.baseApiPath.slice(0, -1) : this.baseApiPath;
                    const ep = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
                    return `${this.apiUrl}${apiBase}/${ep}`;
                },
                async fetchDatabases() {
                    this.isLoadingDatabases = true; this.error = null; this.databases = []; this.tables = [];
                    this.rows = []; this.columns = []; this.selectedDatabase = null; this.selectedTable = null;
                    try {
                        const response = await axios.get(this.getApiPath('databases'));
                        this.databases = response.data.databases || [];
                    } catch (err) { this.error = `Failed to load databases: ${err.response?.data?.error || err.message}`; }
                    finally { this.isLoadingDatabases = false; }
                },
                async selectDatabase(dbName) {
                    if (this.selectedDatabase === dbName) return;
                    this.selectedDatabase = dbName; this.selectedTable = null; this.isLoadingTables = true;
                    this.error = null; this.tables = []; this.rows = []; this.columns = [];
                    this.currentPage = 1; this.totalRows = 0; // Reset pagination
                    try {
                        const response = await axios.get(this.getApiPath(`databases/${dbName}/tables`));
                        this.tables = response.data.tables || [];
                    } catch (err) { this.error = `Failed to load tables for ${dbName}: ${err.response?.data?.error || err.message}`; }
                    finally { this.isLoadingTables = false; }
                },
                async selectTable(tableName, page = 1) { // Add page parameter
                     if (!this.selectedDatabase || (this.selectedTable === tableName && this.currentPage === page)) return; // Avoid refetch if same table/page

                     this.selectedTable = tableName;
                     this.currentPage = page; // Set current page
                     this.isLoadingRows = true;
                     this.error = null;
                     this.rows = [];
                     this.columns = [];
                     this.primaryKeyColumn = null; // Reset PK detection

                     try {
                         // Fetch structure only once if columns are empty
                         if (this.columns.length === 0) {
                             const structureResponse = await axios.get(this.getApiPath(`databases/${this.selectedDatabase}/tables/${tableName}/structure`));
                             this.columns = structureResponse.data.columns || [];
                             // Basic Primary Key Detection (assume first column or one named 'id')
                             if (this.columns.length > 0) {
                                const idCol = this.columns.find(c => c.Field.toLowerCase() === 'id');
                                const pkCol = this.columns.find(c => c.Key === 'PRI');
                                this.primaryKeyColumn = pkCol ? pkCol.Field : (idCol ? idCol.Field : this.columns[0].Field);
                                console.log("Detected PK:", this.primaryKeyColumn);
                             }
                         }
                         // Fetch rows for the current page
                         const rowsResponse = await axios.get(this.getApiPath(`databases/${this.selectedDatabase}/tables/${tableName}/rows?limit=${this.rowsPerPage}&page=${this.currentPage}`));
                         this.rows = rowsResponse.data.rows || [];
                         this.totalRows = rowsResponse.data.totalRows || 0;

                     } catch (err) {
                         console.error(`Error fetching data for ${this.selectedDatabase}.${tableName}:`, err);
                         this.error = `Failed to load data for ${tableName}: ${err.response?.data?.error || err.message}`;
                         this.columns = []; this.rows = []; this.totalRows = 0;
                     } finally {
                         this.isLoadingRows = false;
                     }
                },
                // --- Row Actions ---
                openEditModal(row, index) {
                    if (!this.primaryKeyColumn) {
                        this.error = 'Cannot edit row: Primary key column not identified.';
                        return;
                    }
                    // Deep copy the row to avoid modifying the original data directly
                    this.editingRow = JSON.parse(JSON.stringify(row));
                    this.editingRowIndex = index;
                    this.editModalInstance?.show();
                },
                async saveRowChanges() {
                    if (!this.editingRow || !this.primaryKeyColumn || this.editingRow[this.primaryKeyColumn] === undefined) {
                        this.error = 'Error saving: Missing data or primary key for editing.';
                        return;
                    }
                    const pkValue = this.editingRow[this.primaryKeyColumn];
                    // Prepare updates, excluding the PK itself
                    const updates = { ...this.editingRow };
                    delete updates[this.primaryKeyColumn];

                    this.isLoadingRows = true; // Indicate loading state
                    this.error = null;
                    try {
                        await axios.put(this.getApiPath(`databases/${this.selectedDatabase}/tables/${this.selectedTable}/rows`), {
                            pkColumn: this.primaryKeyColumn,
                            pkValue: pkValue,
                            updates: updates
                        });
                        // Refresh current page data after successful update
                        await this.selectTable(this.selectedTable, this.currentPage);
                        this.editModalInstance?.hide(); // Close modal on success
                    } catch (err) {
                        console.error("Error updating row:", err);
                        this.error = `Failed to update row (PK: ${pkValue}): ${err.response?.data?.error || err.message}`;
                        // Keep modal open on error
                    } finally {
                         this.isLoadingRows = false;
                    }
                },
                confirmDeleteRow(row, index) {
                    if (!this.primaryKeyColumn) {
                        this.error = 'Cannot delete row: Primary key column not identified.';
                        return;
                    }
                    const pkValue = row[this.primaryKeyColumn];
                    if (pkValue === undefined) {
                         this.error = 'Cannot delete row: Primary key value not found.';
                         return;
                    }
                    this.$emit('show-confirm', {
                        message: `Are you sure you want to delete the row where ${this.primaryKeyColumn} = ${pkValue}? This action cannot be undone.`,
                        callback: this.executeDeleteRow,
                        param: { pkValue: pkValue } // Pass PK value
                    });
                },
                async executeDeleteRow(params) {
                    const { pkValue } = params;
                    this.isLoadingRows = true;
                    this.error = null;
                    try {
                        await axios.delete(this.getApiPath(`databases/${this.selectedDatabase}/tables/${this.selectedTable}/rows`), {
                           // Send PK info in the request body for DELETE
                           data: {
                               pkColumn: this.primaryKeyColumn,
                               pkValue: pkValue
                           }
                        });
                        // Refresh data (go to page 1 if last item on page deleted?) - simple refresh for now
                        await this.selectTable(this.selectedTable, this.currentPage);
                    } catch (err) {
                        console.error("Error deleting row:", err);
                        this.error = `Failed to delete row (PK: ${pkValue}): ${err.response?.data?.error || err.message}`;
                    } finally {
                         this.isLoadingRows = false;
                    }
                },
                // --- Table Actions ---
                confirmDeleteTable(tableName) {
                     this.$emit('show-confirm', {
                        message: `Are you sure you want to permanently delete the table "${tableName}" from database "${this.selectedDatabase}"? This action cannot be undone.`,
                        callback: this.executeDeleteTable,
                        param: tableName
                    });
                },
                async executeDeleteTable(tableName) {
                    this.isLoadingTables = true; // Use table loading indicator
                    this.error = null;
                    try {
                        await axios.delete(this.getApiPath(`databases/${this.selectedDatabase}/tables/${tableName}`));
                        // Refresh tables list and reset view if the deleted table was selected
                        if (this.selectedTable === tableName) {
                            this.selectedTable = null;
                            this.rows = [];
                            this.columns = [];
                            this.currentPage = 1;
                            this.totalRows = 0;
                        }
                        // Re-fetch tables for the current DB
                        const response = await axios.get(this.getApiPath(`databases/${this.selectedDatabase}/tables`));
                        this.tables = response.data.tables || [];

                    } catch (err) {
                         console.error(`Error deleting table ${tableName}:`, err);
                         this.error = `Failed to delete table "${tableName}": ${err.response?.data?.error || err.message}`;
                    } finally {
                        this.isLoadingTables = false;
                    }
                },
                 // --- Custom Query ---
                 openQueryModal() {
                     this.customQuery = '';
                     this.queryResult = null;
                     this.queryError = null;
                     this.queryResultType = 'none';
                     this.queryModalInstance?.show();
                 },
                 async runCustomQuery() {
                     if (!this.customQuery.trim()) {
                         this.queryError = 'Query cannot be empty.';
                         return;
                     }
                     this.isQueryRunning = true;
                     this.queryResult = null;
                     this.queryError = null;
                     this.queryResultType = 'none';

                     try {
                         const response = await axios.post(this.getApiPath(`databases/${this.selectedDatabase}/run-query`), {
                             query: this.customQuery
                         });
                         // Determine result type based on response structure
                         if (response.data.rows !== undefined) {
                             this.queryResultType = 'rows';
                             this.queryResult = response.data; // { rows: [], fields: [] }
                         } else if (response.data.affectedRows !== undefined) {
                             this.queryResultType = 'affected';
                             this.queryResult = response.data; // { affectedRows: N }
                         } else {
                              this.queryResultType = 'other';
                              this.queryResult = response.data.result !== undefined ? response.data.result : response.data; // Fallback
                         }

                     } catch (err) {
                         console.error("Error running custom query:", err);
                         this.queryError = `Query failed: ${err.response?.data?.error || err.message}`;
                         this.queryResultType = 'error';
                     } finally {
                         this.isQueryRunning = false;
                     }
                 },
                 // --- Helpers ---
                 formatValue(value) {
                    if (value === null) return '<i class="text-muted">NULL</i>';
                    if (typeof value === 'string') {
                         const tempDiv = document.createElement('div');
                         tempDiv.textContent = value;
                         const escapedValue = tempDiv.innerHTML;
                         if (escapedValue.length > 100) {
                            return escapedValue.substring(0, 100) + '...';
                         }
                         return escapedValue;
                    }
                    if (typeof value === 'object') { try { return JSON.stringify(value); } catch { return '[Object]'; } }
                    return value;
                },
                 // --- Pagination ---
                 changePage(newPage) {
                    if (newPage >= 1 && newPage <= this.totalPages && newPage !== this.currentPage) {
                        this.selectTable(this.selectedTable, newPage);
                    }
                 },
                 // --- Modal Initialization ---
                 initializeModals() {
                     // Edit Row Modal
                     const editModalElement = this.$refs.editRowModal;
                     if (editModalElement && typeof bootstrap !== 'undefined') {
                         this.editModalInstance = new bootstrap.Modal(editModalElement);
                     } else { console.error("Could not initialize edit row modal."); }
                     // Run Query Modal
                     const queryModalElement = this.$refs.runQueryModal;
                      if (queryModalElement && typeof bootstrap !== 'undefined') {
                          this.queryModalInstance = new bootstrap.Modal(queryModalElement);
                      } else { console.error("Could not initialize run query modal."); }
                 }
            },
            mounted() {
                this.fetchDatabases(); // Load databases on mount
                // Initialize Bootstrap Modals after component is mounted
                nextTick(() => {
                    this.initializeModals();
                });
            },
            // Watch for selected table changes to reset page
            watch: {
                selectedTable(newTable, oldTable) {
                    if (newTable !== oldTable) {
                        this.currentPage = 1; // Reset to page 1 when table changes
                        // Fetching is handled by selectTable method
                    }
                }
            },
            template: `
                <div class="card">
                    <div class="card-header"> <h3 class="m-0"><i class="fas fa-edit"></i> Manage Database</h3> </div>
                    <div class="card-body p-0">
                        <div class="db-manager-layout">
                            <div class="db-sidebar">
                                <h5>Databases</h5>
                                <div v-if="isLoadingDatabases" class="text-center"> <div class="spinner-border spinner-border-sm" role="status"></div> </div>
                                <div v-else class="list-group list-group-flush mb-3">
                                    <a v-for="db in databases" :key="db" href="#" class="list-group-item list-group-item-action py-1" :class="{ active: selectedDatabase === db }" @click.prevent="selectDatabase(db)">
                                       <span><i class="fas fa-database me-2"></i>{{ db }}</span>
                                    </a>
                                    <small v-if="!databases.length" class="text-muted p-2">No databases found.</small>
                                </div>

                                <div v-if="selectedDatabase">
                                    <h5 class="mt-3">Tables in {{ selectedDatabase }}</h5>
                                    <div v-if="isLoadingTables" class="text-center"> <div class="spinner-border spinner-border-sm" role="status"></div> </div>
                                    <div v-else class="list-group list-group-flush">
                                        <a v-for="table in tables" :key="table" href="#" class="list-group-item list-group-item-action py-1" :class="{ active: selectedTable === table }" @click.prevent="selectTable(table, 1)">
                                            <span><i class="fas fa-table me-2"></i>{{ table }}</span>
                                            <span class="sidebar-item-actions">
                                                <i class="fas fa-trash-alt text-danger clickable" title="Delete Table" @click.stop.prevent="confirmDeleteTable(table)"></i>
                                            </span>
                                        </a>
                                        <small v-if="!tables.length" class="text-muted p-2">No tables found.</small>
                                    </div>
                                </div>
                            </div>

                            <div class="db-content">
                                <div v-if="error" class="alert alert-danger alert-dismissible fade show" role="alert">
                                    {{ error }}
                                    <button type="button" class="btn-close" @click="error = null" aria-label="Close"></button>
                                </div>

                                <div v-if="!selectedDatabase" class="text-center text-muted mt-5"> <i class="fas fa-arrow-left fa-2x mb-3"></i> <p>Select a database from the sidebar.</p> </div>
                                <div v-else-if="!selectedTable && !isLoadingTables" class="text-center text-muted mt-5"> <i class="fas fa-arrow-left fa-2x mb-3"></i> <p>Select a table from the sidebar.</p> </div>

                                <template v-else-if="selectedTable">
                                    <div class="db-content-header">
                                        <h4>Data: {{ selectedDatabase }}.{{ selectedTable }}</h4>
                                        <button class="btn btn-sm btn-outline-secondary" @click="openQueryModal" title="Run Custom SQL Query">
                                            <i class="fas fa-terminal me-1"></i> Run Query
                                        </button>
                                    </div>

                                    <div v-if="isLoadingRows" class="text-center mt-4"> <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div> </div>
                                    <div v-else-if="!columns.length" class="alert alert-warning"> No columns found or unable to load table structure. </div>
                                    <div v-else-if="!rows.length" class="alert alert-info"> Table appears to be empty. </div>
                                    <div v-else class="table-responsive-manager">
                                        <table class="table table-bordered table-striped table-sm table-hover">
                                            <thead>
                                                <tr>
                                                    <th scope="col" style="width: 80px;">Actions</th> <th v-for="col in columns" :key="col.Field" scope="col">
                                                        {{ col.Field }}
                                                        <i v-if="col.Key === 'PRI'" class="fas fa-key text-warning ms-1" title="Primary Key"></i>
                                                        <small class="text-muted d-block">({{ col.Type }})</small>
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="(row, rowIndex) in rows" :key="row[primaryKeyColumn] || rowIndex"> <td class="action-buttons">
                                                        <span @click="openEditModal(row, rowIndex)" class="text-primary" title="Edit Row"> <i class="fas fa-pencil-alt"></i> </span>
                                                        <span @click="confirmDeleteRow(row, rowIndex)" class="text-danger" title="Delete Row"> <i class="fas fa-trash-alt"></i> </span>
                                                    </td>
                                                    <td v-for="col in columns" :key="col.Field" v-html="formatValue(row[col.Field])" :title="row[col.Field]"></td> </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                     <nav v-if="totalRows > 0 && totalPages > 1" aria-label="Table navigation" class="pagination-controls">
                                         <ul class="pagination pagination-sm justify-content-center">
                                             <li class="page-item" :class="{ disabled: currentPage === 1 }">
                                                 <a class="page-link" href="#" @click.prevent="changePage(currentPage - 1)">&laquo; Prev</a>
                                             </li>
                                             <li class="page-item disabled"><span class="page-link">Page {{ currentPage }} of {{ totalPages }}</span></li>
                                              <li class="page-item" :class="{ disabled: currentPage === totalPages }">
                                                 <a class="page-link" href="#" @click.prevent="changePage(currentPage + 1)">Next &raquo;</a>
                                             </li>
                                         </ul>
                                         <p class="text-center text-muted small">Showing rows {{ (currentPage - 1) * rowsPerPage + 1 }} - {{ Math.min(currentPage * rowsPerPage, totalRows) }} of {{ totalRows }}</p>
                                     </nav>
                                </template> </div> </div> </div> <div class="modal fade" ref="editRowModal" tabindex="-1" aria-labelledby="editRowModalLabel" aria-hidden="true">
                        <div class="modal-dialog modal-lg">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="editRowModalLabel">Edit Row in {{ selectedTable }}</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body" v-if="editingRow">
                                    <div v-for="col in columns" :key="col.Field" class="mb-2">
                                        <label :for="'editField_' + col.Field" class="form-label">{{ col.Field }} <small class="text-muted">({{ col.Type }})</small></label>
                                        <input v-if="col.Type.toLowerCase().includes('text') || col.Type.toLowerCase().includes('blob')"
                                               :id="'editField_' + col.Field"
                                               class="form-control form-control-sm"
                                               v-model="editingRow[col.Field]"
                                               :disabled="col.Field === primaryKeyColumn"
                                               as="textarea" rows="3">
                                        </input>
                                        <input v-else
                                               :type="col.Type.toLowerCase().includes('int') || col.Type.toLowerCase().includes('decimal') ? 'number' : 'text'"
                                               :id="'editField_' + col.Field"
                                               class="form-control form-control-sm"
                                               v-model="editingRow[col.Field]"
                                               :disabled="col.Field === primaryKeyColumn">
                                    </div>
                                    <div v-if="error" class="alert alert-danger mt-2">{{ error }}</div>
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                    <button type="button" class="btn btn-primary" @click="saveRowChanges" :disabled="isLoadingRows">
                                        <span v-if="isLoadingRows" class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                                        Save Changes
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                     <div class="modal fade" ref="runQueryModal" tabindex="-1" aria-labelledby="runQueryModalLabel" aria-hidden="true">
                        <div class="modal-dialog modal-xl"> <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="runQueryModalLabel">Run Custom Query in {{ selectedDatabase }}</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <div class="mb-3">
                                        <label for="customQueryTextarea" class="form-label">SQL Query (Only SELECT is recommended for safety)</label>
                                        <textarea class="form-control font-monospace" id="customQueryTextarea" rows="5" v-model="customQuery" placeholder="e.g., SELECT * FROM your_table WHERE id = 1;"></textarea>
                                        <small class="text-muted">Warning: Running arbitrary SQL queries can be dangerous. Avoid UPDATE, DELETE, DROP unless absolutely necessary.</small>
                                    </div>
                                    <button class="btn btn-primary" @click="runCustomQuery" :disabled="isQueryRunning || !customQuery.trim()">
                                         <span v-if="isQueryRunning" class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                                         Run Query
                                    </button>
                                    <hr/>
                                    <div v-if="isQueryRunning" class="text-center"> <div class="spinner-border text-primary" role="status"></div> </div>
                                    <div v-if="queryError" class="alert alert-danger mt-3">{{ queryError }}</div>
                                    <div v-if="queryResult">
                                        <div v-if="queryResultType === 'rows'" class="mt-3">
                                            <h6>Query Results ({{ queryResult.rows?.length || 0 }} rows)</h6>
                                            <div v-if="queryResult.rows?.length > 0" class="query-results-table table-responsive">
                                                <table class="table table-sm table-bordered table-striped">
                                                    <thead>
                                                        <tr> <th v-for="field in queryResult.fields" :key="field.name">{{ field.name }}</th> </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr v-for="(resRow, rIdx) in queryResult.rows" :key="rIdx">
                                                             <td v-for="field in queryResult.fields" :key="field.name" v-html="formatValue(resRow[field.name])"></td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <p v-else class="text-muted">Query executed successfully, but returned no rows.</p>
                                        </div>
                                        <div v-else-if="queryResultType === 'affected'" class="alert alert-success mt-3">
                                            Query executed successfully. Affected Rows: {{ queryResult.affectedRows }}
                                        </div>
                                         <div v-else-if="queryResultType === 'other'" class="alert alert-info mt-3">
                                             Query executed successfully. Result: <pre>{{ JSON.stringify(queryResult, null, 2) }}</pre>
                                         </div>
                                    </div>
                                </div>
                                <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> </div>
                        </div> </div>
                    </div>


                </div> `
        });

        // Mount the app to the DOM
        app.mount('#app');

    </script>

</body>
</html>
